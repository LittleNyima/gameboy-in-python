'''
PLEASE DON'T MODIFY THIS FILE
=============================
This file is auto-generated by `tools/codegen/instructions.py`.
To re-generate this file, run:
$ python tools/codegen/instructions.py --target gameboy/core/instructions.py
To preview the generated contents, run:
$ python tools/codegen/instructions.py --print
'''

import json
import os
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional, cast

from gameboy.common.typings import U8


@dataclass(frozen=True)
class Operand:
    name: str
    bytes: int = 1
    immediate: bool = True
    decrement: bool = False
    increment: bool = False

    def __str__(self) -> str:
        format_string = '{}{}{}' if self.immediate else '[{}{}{}]'
        dec_string = '-' if self.decrement else ''
        inc_string = '+' if self.increment else ''
        return format_string.format(self.name, inc_string, dec_string)

    def __repr__(self) -> str:
        return str(self)


class OperandType(Enum):
    NONE = Operand(name='NONE')
    # FMT_PREFIX{operand_types}

    @classmethod
    def from_dict(cls, data: Optional[Dict[str, Any]]):
        if data is None:
            return cls.NONE
        name = cast(str, data.get('name'))
        if name.startswith('$'):
            name = name.replace('$', 'hex')
        if name.isdigit():
            name = 'bit' + name
        if not data.get('immediate', True):
            name += '_mem'
        if data.get('decrement', False):
            name += '_dec'
        if data.get('increment', False):
            name += '_inc'
        return cls[name.upper()]


class FlagType(Enum):
    UNCHANGE = '-'
    SET = '1'
    RESET = '0'
    DEDUCTED_Z = 'Z'
    DEDUCTED_N = 'N'
    DEDUCTED_H = 'H'
    DEDUCTED_C = 'C'

    @classmethod
    def from_string(cls, content: str):
        return cls(content)


class InstrType(Enum):
    NONE = 'NONE'
    # FMT_PREFIX{instr_types}


@dataclass
class Instruction:
    mnemonic: InstrType
    bytes: int
    cycles: List[int]
    operand0: OperandType
    operand1: OperandType
    immediate: bool
    flag_z: FlagType
    flag_n: FlagType
    flag_h: FlagType
    flag_c: FlagType

    def __str__(self) -> str:
        content = self.mnemonic.value
        if self.operand0 != OperandType.NONE:
            content += f' {self.operand0.value}'
        if self.operand1 != OperandType.NONE:
            content += f' {self.operand1.value}'
        return f'Instruction({content})'

    def __repr__(self) -> str:
        return str(self)


def load_instruction_subset(
        subset: Dict[str, Dict[str, Any]],
) -> List[Instruction]:
    instructions = []
    for opcode in sorted(subset):
        instr = subset.get(opcode, dict())
        mnemonic = cast(str, instr.get('mnemonic'))
        nbytes = cast(int, instr.get('bytes'))
        cycles = cast(List[int], instr.get('cycles'))
        operands = cast(List[Dict[str, Any]], instr.get('operands'))
        operand0 = OperandType.from_dict(
            operands[0] if len(operands) > 0 else None,
        )
        operand1 = OperandType.from_dict(
            operands[1] if len(operands) > 1 else None,
        )
        immediate = cast(bool, instr.get('immediate'))
        flags = cast(Dict[str, str], instr.get('flags'))
        instructions.append(
            Instruction(
                mnemonic=InstrType[mnemonic],
                bytes=nbytes,
                cycles=cycles,
                operand0=operand0,
                operand1=operand1,
                immediate=immediate,
                flag_z=FlagType.from_string(flags.get('Z', '')),
                flag_n=FlagType.from_string(flags.get('N', '')),
                flag_h=FlagType.from_string(flags.get('H', '')),
                flag_c=FlagType.from_string(flags.get('C', '')),
            ),
        )
    return instructions


def load_instruction_set():
    path = os.path.join(os.path.dirname(__file__), 'opcodes.json')
    with open(path) as f:
        opcodes = json.load(f)
    return (
        load_instruction_subset(opcodes.get('unprefixed', dict())),
        load_instruction_subset(opcodes.get('cbprefixed', dict())),
    )


UNPREFIXED, CBPREFIXED = load_instruction_set()


def decode_opcode(opcode: U8, is_cb: bool) -> Instruction:
    return CBPREFIXED[opcode] if is_cb else UNPREFIXED[opcode]
