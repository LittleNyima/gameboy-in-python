'''
PLEASE DON'T MODIFY THIS FILE
=============================
This file is auto-generated by `tools/codegen/instructions.py`.
To re-generate this file, run:
$ python tools/codegen/instructions.py --target gameboy/core/instructions.py
To preview the generated contents, run:
$ python tools/codegen/instructions.py --print
'''

import json
import os
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional, cast

from gameboy.common.typings import U8


@dataclass(frozen=True)
class Operand:
    name: str
    bytes: int = 1
    immediate: bool = True
    decrement: bool = False
    increment: bool = False

    def __str__(self) -> str:
        format_string = '{}{}{}' if self.immediate else '[{}{}{}]'
        dec_string = '-' if self.decrement else ''
        inc_string = '+' if self.increment else ''
        return format_string.format(self.name, inc_string, dec_string)

    def __repr__(self) -> str:
        return str(self)


class OperandType(Enum):
    NONE = Operand(name='NONE')
    A = Operand(name='A')
    A16 = Operand(name='a16')
    A16_MEM = Operand(name='a16', immediate=False)
    A8_MEM = Operand(name='a8', immediate=False)
    AF = Operand(name='AF')
    B = Operand(name='B')
    BC = Operand(name='BC')
    BC_MEM = Operand(name='BC', immediate=False)
    BIT0 = Operand(name='0')
    BIT1 = Operand(name='1')
    BIT2 = Operand(name='2')
    BIT3 = Operand(name='3')
    BIT4 = Operand(name='4')
    BIT5 = Operand(name='5')
    BIT6 = Operand(name='6')
    BIT7 = Operand(name='7')
    C = Operand(name='C')
    C_MEM = Operand(name='C', immediate=False)
    D = Operand(name='D')
    DE = Operand(name='DE')
    DE_MEM = Operand(name='DE', immediate=False)
    E = Operand(name='E')
    E8 = Operand(name='e8')
    H = Operand(name='H')
    HEX00 = Operand(name='$00')
    HEX08 = Operand(name='$08')
    HEX10 = Operand(name='$10')
    HEX18 = Operand(name='$18')
    HEX20 = Operand(name='$20')
    HEX28 = Operand(name='$28')
    HEX30 = Operand(name='$30')
    HEX38 = Operand(name='$38')
    HL = Operand(name='HL')
    HL_MEM = Operand(name='HL', immediate=False)
    HL_MEM_DEC = Operand(name='HL', immediate=False, decrement=True)
    HL_MEM_INC = Operand(name='HL', immediate=False, increment=True)
    L = Operand(name='L')
    N16 = Operand(name='n16')
    N8 = Operand(name='n8')
    NC = Operand(name='NC')
    NZ = Operand(name='NZ')
    SP = Operand(name='SP')
    SP_INC = Operand(name='SP', increment=True)
    Z = Operand(name='Z')

    @classmethod
    def from_dict(cls, data: Optional[Dict[str, Any]]):
        if data is None:
            return cls.NONE
        name = cast(str, data.get('name'))
        if name.startswith('$'):
            name = name.replace('$', 'hex')
        if name.isdigit():
            name = 'bit' + name
        if not data.get('immediate', True):
            name += '_mem'
        if data.get('decrement', False):
            name += '_dec'
        if data.get('increment', False):
            name += '_inc'
        return cls[name.upper()]


class FlagType(Enum):
    UNCHANGE = '-'
    SET = '1'
    RESET = '0'
    DEDUCTED_Z = 'Z'
    DEDUCTED_N = 'N'
    DEDUCTED_H = 'H'
    DEDUCTED_C = 'C'

    @classmethod
    def from_string(cls, content: str):
        return cls(content)


class InstrType(Enum):
    NONE = 'NONE'
    ADC = 'ADC'
    ADD = 'ADD'
    AND = 'AND'
    BIT = 'BIT'
    CALL = 'CALL'
    CCF = 'CCF'
    CP = 'CP'
    CPL = 'CPL'
    DAA = 'DAA'
    DEC = 'DEC'
    DI = 'DI'
    EI = 'EI'
    HALT = 'HALT'
    ILLEGAL_D3 = 'ILLEGAL_D3'
    ILLEGAL_DB = 'ILLEGAL_DB'
    ILLEGAL_DD = 'ILLEGAL_DD'
    ILLEGAL_E3 = 'ILLEGAL_E3'
    ILLEGAL_E4 = 'ILLEGAL_E4'
    ILLEGAL_EB = 'ILLEGAL_EB'
    ILLEGAL_EC = 'ILLEGAL_EC'
    ILLEGAL_ED = 'ILLEGAL_ED'
    ILLEGAL_F4 = 'ILLEGAL_F4'
    ILLEGAL_FC = 'ILLEGAL_FC'
    ILLEGAL_FD = 'ILLEGAL_FD'
    INC = 'INC'
    JP = 'JP'
    JR = 'JR'
    LD = 'LD'
    LDH = 'LDH'
    NOP = 'NOP'
    OR = 'OR'
    POP = 'POP'
    PREFIX = 'PREFIX'
    PUSH = 'PUSH'
    RES = 'RES'
    RET = 'RET'
    RETI = 'RETI'
    RL = 'RL'
    RLA = 'RLA'
    RLC = 'RLC'
    RLCA = 'RLCA'
    RR = 'RR'
    RRA = 'RRA'
    RRC = 'RRC'
    RRCA = 'RRCA'
    RST = 'RST'
    SBC = 'SBC'
    SCF = 'SCF'
    SET = 'SET'
    SLA = 'SLA'
    SRA = 'SRA'
    SRL = 'SRL'
    STOP = 'STOP'
    SUB = 'SUB'
    SWAP = 'SWAP'
    XOR = 'XOR'


@dataclass
class Instruction:
    mnemonic: InstrType
    bytes: int
    cycles: List[int]
    operand0: OperandType
    operand1: OperandType
    immediate: bool
    flag_z: FlagType
    flag_n: FlagType
    flag_h: FlagType
    flag_c: FlagType

    def __str__(self) -> str:
        content = self.mnemonic.value
        if self.operand0 != OperandType.NONE:
            content += f' {self.operand0.value}'
        if self.operand1 != OperandType.NONE:
            content += f' {self.operand1.value}'
        return f'Instruction({content})'

    def __repr__(self) -> str:
        return str(self)


def load_instruction_subset(
        subset: Dict[str, Dict[str, Any]],
) -> List[Instruction]:
    instructions = []
    for opcode in sorted(subset):
        instr = subset.get(opcode, dict())
        mnemonic = cast(str, instr.get('mnemonic'))
        nbytes = cast(int, instr.get('bytes'))
        cycles = cast(List[int], instr.get('cycles'))
        operands = cast(List[Dict[str, Any]], instr.get('operands'))
        operand0 = OperandType.from_dict(
            operands[0] if len(operands) > 0 else None,
        )
        operand1 = OperandType.from_dict(
            operands[1] if len(operands) > 1 else None,
        )
        immediate = cast(bool, instr.get('immediate'))
        flags = cast(Dict[str, str], instr.get('flags'))
        instructions.append(
            Instruction(
                mnemonic=InstrType[mnemonic],
                bytes=nbytes,
                cycles=cycles,
                operand0=operand0,
                operand1=operand1,
                immediate=immediate,
                flag_z=FlagType.from_string(flags.get('Z', '')),
                flag_n=FlagType.from_string(flags.get('N', '')),
                flag_h=FlagType.from_string(flags.get('H', '')),
                flag_c=FlagType.from_string(flags.get('C', '')),
            ),
        )
    return instructions


def load_instruction_set():
    path = os.path.join(os.path.dirname(__file__), 'opcodes.json')
    with open(path) as f:
        opcodes = json.load(f)
    return (
        load_instruction_subset(opcodes.get('unprefixed', dict())),
        load_instruction_subset(opcodes.get('cbprefixed', dict())),
    )


UNPREFIXED, CBPREFIXED = load_instruction_set()


def decode_opcode(opcode: U8, is_cb: bool) -> Instruction:
    return CBPREFIXED[opcode] if is_cb else UNPREFIXED[opcode]
